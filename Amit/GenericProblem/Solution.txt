1. Will the following class compile? If not, why?
public final class Algorithm {
    public static T max(T x, T y) {
        return x > y ? x : y;
    }
}
Ans:
No, The greater than (>) operator applies only to primitive numeric types.


2. If the compiler erases all type parameters at compile time, why should you use generics?
Ans:
You should use generics because:
• The Java compiler enforces tighter type checks on generic code at compile time.
• Generics support programming types as parameters.
• Generics enable you to implement generic algorithms.

3. What is the following class converted to after type erasure?
public class Pair<K, V> {
  public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
  public K getKey(); { return key; }
    public V getValue(); { return value; }
 public void setKey(K key)     { this.key = key; }
    public void setValue(V value) { this.value = value; }
private K key;
  private V value;
}

Ans:
public class Pair {
public Pair(Object key, Object value) {
        this.key = key;
        this.value = value;
    }
public Object getKey()   { return key; }
    public Object getValue() { return value;
 }
public void setKey(Object key)     { this.key = key; }
    public void setValue(Object value) { this.value = value; }
 private Object key;
 private Object value;

4. What is the following method converted to after type erasure?
public static <T extends Comparable<T>>
    int findFirstGreaterThan(T[] at, T elem) {
    // . . .

Ans:
public static int findFirstGreaterThan(Comparable[] at, Comparable elem) {
    // ...
    }

5. Will the following method compile? If not, why?
public static void print(List<? extends Number> list) {
    for (Number n : list)
        System.out.print(n + " ");
    System.out.println();
}

Ans:
Yes, Tha above method will. Get complied. 

6. Will the following class compile? If not, why?
public class Singleton<T> {


    public static T getInstance() {
        if (instance == null)
            instance = new Singleton<T>();

        return instance;
    }

    private static T instance = null;
}

Ans:
No, Because you cannot create a static field of the type parameter T.

7. Will the following code compile? If not, why?

Node<Circle> nc = new Node<>();
Node<Shape>  ns = nc;
Consider this class:
class Node<T> implements Comparable<T> {
    public int compareTo(T obj) { /* . . . */ }
    // . . .
}

Ans:
No, Because Node<Circle> is not a subtype of Node<Shape>.
