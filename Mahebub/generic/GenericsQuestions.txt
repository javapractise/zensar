1. Will the following class compile? If not, why?
public final class Algorithm {
    public static <T> T max(T x, T y) {
        return x > y ? x : y;
    }
}
Answer: No. The greater than (>) operator applies only to primitive numeric types.

2. If the compiler erases all type parameters at compile time, why should you use generics?
Answer: You should use generics because:
The Java compiler enforces tighter type checks on generic code at compile time.
Generics support programming types as parameters.
Generics enable you to implement generic algorithms.

3. What is the following class converted to after type erasure?
public class Pair<K, V> {

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey(); { return key; }
    public V getValue(); { return value; }

    public void setKey(K key)     { this.key = key; }
    public void setValue(V value) { this.value = value; }

    private K key;
    private V value;
}
Answer:
public class Pair {

    public Pair(Object key, Object value) {
        this.key = key;
        this.value = value;
    }

    public Object getKey()   { return key; }
    public Object getValue() { return value; }

    public void setKey(Object key)     { this.key = key; }
    public void setValue(Object value) { this.value = value; }

    private Object key;
    private Object value;
}

4. What is the following method converted to after type erasure?
public static <T extends Comparable<T>>
    int findFirstGreaterThan(T[] at, T elem) {
    // ...
}
Answer:
public static int findFirstGreaterThan(Comparable[] at, Comparable elem) {
    // ...
    }

5. Will the following method compile? If not, why?
public static void print(List<? extends Number> list) {
    for (Number n : list)
        System.out.print(n + " ");
    System.out.println();
}
Answer: Yes.

6. Will the following class compile? If not, why?
public class Singleton<T> {

    public static T getInstance() {
        if (instance == null)
            instance = new Singleton<T>();

        return instance;
    }

    private static T instance = null;
}
Answer: No. You cannot create a static field of the type parameter T.

7. Will the following code compile? If not, why?
Node<Circle> nc = new Node<>();
Node<Shape>  ns = nc;
Answer: No. Because Node<Circle> is not a subtype of Node<Shape>.

8. Will the following code compile? If not, why?
Node<String> node = new Node<>();
Comparable<String> comp = node;
Answer: Yes.
